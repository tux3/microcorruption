#!/usr/bin/python

# This script provides several functions useful for analyzing the decrypted Hollywood code in IDA
# running "analyze(); analyze(0x1616, 70)" will follow the two chain of code buffers and create functions for them
# running "printLightDisassembly()" will then reconstruct the code by disassembling the first instruction of each function

# Pretty hex word output
def fmtw(w):
	return '0x'+format(w, '04X')

# Return the start address of the next buffer from the buffer at pos
def findNextBuf(start):
	# Try to locate the end of the block
	pos = start
	while GetMnem(pos) != 'br' or GetOpnd(pos,0) != 'R13':
		if pos - start > 0xE:
			raise Exception('Couldn\'t find end of code buffer')
		pos = NextHead(pos)
	# Assume the second to last instruction sets up R12 to point to the next block
	pos = PrevHead(pos)
	if pos!=start and PrevHead(pos) != start:
		print('Warning: More than one instruction before setting R12')
	if GetMnem(pos) != 'mov' or GetOpnd(pos, 1) != 'R12' or GetOpType(pos, 0) != o_imm:
		raise Exception('Expected a "MOV #XXXX, R12" instruction')
	op = GetOperandValue(pos, 0)
	op -= 0x3194
	return op

# Tries a bit harder than normal to create an instruction
def forceMakeCode(pos):
	MakeUnkn(pos, DOUNK_SIMPLE)
	if not MakeCode(pos):
		# If MakeCode failed become there's another instruction in the way, overwrite it
		nextInstrEnd = NextNotTail(NextHead(pos))
		if nextInstrEnd-pos <= 0x8:
			print('Warning: Failed to create code at '+fmtw(pos)+', trying harder...')
			MakeUnknown(pos, nextInstrEnd, DOUNK_SIMPLE)
			if not MakeCode(pos):
				raise Exception('Error: Failed to create code at '+fmtw(pos))
		else:
			raise Exception('Error: Failed to create code at '+fmtw(pos))
	Wait() # MakeCode analysis is asynchronous, we need to wait until analysis end to keeep coherency

# Make a function with an autogenerated name for the given code buffer
def genFunc(pos, name):
	# Try to locate the end of the block, marking it as code on the way
	start = pos
	forceMakeCode(pos)
	while GetMnem(pos) != 'br' or GetOpnd(pos,0) != 'R13':
		if pos - start > 0xE:
			raise Exception('Couldn\'t find end of code buffer')
		pos = NextHead(pos, BADADDR)
		forceMakeCode(pos)

	pos = start
	if GetFunctionName(pos) != '':
		print('Warning: Renaming function '+GetFunctionName(pos)+' at '+fmtw(pos))
	else:
		MakeFunction(pos)
	if not MakeName(pos, name):
		renamePos=LocByName(name)
		rename=name+'_'+fmtw(renamePos)
		print('Warning: The name '+name+' already exists, renaming it to '+rename)
		MakeName(renamePos, rename)
		if not MakeName(pos, name):
			raise Exception('Error: Couldn\'t use name '+name+' for this function')

# Generate a name for the function of code buffer number n
def genFuncName(n):
	funcBaseName = 'buf'
	return funcBaseName+format(n,'03')

# Start analyzing the code from the known first buffer at 0x160C
# Will create a function called bufXX for each code buffer, in the order they are executed
def analyze(pos=None, funcNum=None):
	# The start position of the current code buffer
	if pos is None:
		pos = 0x160C
	# Param to generate the name of each code buffer
	if funcNum is None:
		funcNum = 0
	# List of all the buffers we already visited
	visited = []
	print('Starting analysis from address '+fmtw(pos))
	while True:
		if pos in visited:
			raise Exception('Error: Last function loops back to function '+GetFunctionName(pos))
		visited.append(pos)
		name = genFuncName(funcNum)
		genFunc(pos, name)
		funcNum+=1
		nextPos = findNextBuf(pos)
		print('Created function '+name+'. Next buffer is at '+fmtw(nextPos))
		pos = nextPos

# Print a disassembly of the first line of all known buffers in order
def printLightDisassembly():
	# Param to generate the name of each code buffer
	funcNum = 0
	NOTFOUND = 0xFFFFFFFFFFFFFFFF
	
	while True:
		name = genFuncName(funcNum)
		pos = LocByName(name)
		if pos == NOTFOUND:
			break
		print(GetDisasm(pos))
		funcNum+=1
		
# Print a disassembly of all known buffers in order
def printDisassembly():
	# Param to generate the name of each code buffer
	funcNum = 0
	NOTFOUND = 0xFFFFFFFFFFFFFFFF
	
	while True:
		name = genFuncName(funcNum)
		pos = LocByName(name)
		if pos == NOTFOUND:
			break
		end = FindFuncEnd(pos)
		while pos < end:
			print(GetDisasm(pos))
			pos = NextHead(pos)
		funcNum+=1
